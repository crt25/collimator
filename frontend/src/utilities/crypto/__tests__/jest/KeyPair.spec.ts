import { subtle } from "crypto";
import KeyPair from "../../KeyPair";
import TeacherLongTermKeyPair from "../../TeacherLongTermKeyPair";
import StudentKeyPair from "../../StudentKeyPair";
import EphemeralKey from "../../EphemeralKey";

type KeyType = "TeacherKeyPair" | "StudentKeyPair";

const allKeyTypes: KeyType[] = ["TeacherKeyPair", "StudentKeyPair"];

const crypto = subtle as SubtleCrypto;

const generateStudentKeyPair = (): Promise<StudentKeyPair> =>
  StudentKeyPair.generate(crypto);

const generateTeacherKeyPair = (): Promise<TeacherLongTermKeyPair> =>
  TeacherLongTermKeyPair.generate(crypto);

const generateKeyPair = (type: KeyType): Promise<KeyPair> =>
  type === "TeacherKeyPair"
    ? generateStudentKeyPair()
    : generateTeacherKeyPair();

const createKeyPair = (type: KeyType, keyPair: CryptoKeyPair): KeyPair =>
  type === "TeacherKeyPair"
    ? new TeacherLongTermKeyPair(crypto, keyPair)
    : new StudentKeyPair(crypto, keyPair);

describe("KeyPair", () => {
  describe.each(allKeyTypes)("%s", (type) => {
    it("generates a key pair", async () => {
      await expect(generateKeyPair(type)).resolves.not.toThrow();
    });

    describe("exportPublicKey", () => {
      it("exports the public key", async () => {
        const keyPair = await generateKeyPair(type);
        const publicKey = await keyPair.exportPublicKey();

        expect(publicKey).toBeDefined();
        expect(publicKey).toEqual({
          // we expect the key type to be EC with the P-521 curve
          kty: "EC",
          crv: "P-521",
          // it was exported so it should always be true
          ext: true,
          key_ops: [],
          x: expect.any(String),
          y: expect.any(String),
        });
      });
    });

    describe("unportected export and import", () => {
      it("exports and imports the key pair", async () => {
        const keyPair = await generateKeyPair(type);
        const serializedKeyPair = await keyPair.exportUnprotected();
        const importedKeyPair = createKeyPair(
          type,
          await KeyPair.importUnprotected(crypto, serializedKeyPair),
        );

        expect(importedKeyPair).toBeInstanceOf(KeyPair);
        const reExportedKeyPair = await importedKeyPair.exportUnprotected();

        // ensure we can export and import the key pair without loss of information
        expect(reExportedKeyPair).toEqual(serializedKeyPair);
      });
    });
  });

  describe("deriveSharedEphemeralKey", () => {
    it("derives a shared ephemeral key", async () => {
      const teacherKeyPair = await generateTeacherKeyPair();
      const studentKeyPair = await generateStudentKeyPair();

      const myPublicKey = await teacherKeyPair.exportPublicKey();
      const otherPublicKey = await studentKeyPair.exportPublicKey();

      const ephemeralKey1 =
        await teacherKeyPair.deriveSharedEphemeralKey(otherPublicKey);
      const ephemeralKey2 = await studentKeyPair.deriveSharedEphemeralKey(
        myPublicKey,
        await teacherKeyPair.getPublicKeyFingerprint(),
      );

      expect(ephemeralKey1).toBeInstanceOf(EphemeralKey);
      expect(ephemeralKey2).toBeInstanceOf(EphemeralKey);

      const plainText = new Uint8Array([1, 2, 3, 4, 5]);
      const cipherText1 = await ephemeralKey1.encrypt(plainText);
      const cipherText2 = await ephemeralKey2.encrypt(plainText);

      // dummy test to ensure the encryption is not a no-op
      expect(cipherText1).not.toEqual(plainText);
      expect(cipherText2).not.toEqual(plainText);

      // randomized encryption is not secure under IND-CPA
      expect(cipherText1).not.toEqual(cipherText2);

      // ensure the keys can decrypt the ciphertext generated by themselves
      const cipherText1DecryptedByKey1 = new Uint8Array(
        await ephemeralKey1.decrypt(cipherText1),
      );

      const cipherText2DecryptedByKey2 = new Uint8Array(
        await ephemeralKey2.decrypt(cipherText2),
      );

      expect(cipherText1DecryptedByKey1).toEqual(plainText);
      expect(cipherText2DecryptedByKey2).toEqual(plainText);

      // ensure the keys can decrypt the ciphertext generated by the other key
      const cipherText1DecryptedByKey2 = new Uint8Array(
        await ephemeralKey2.decrypt(cipherText1),
      );
      const cipherText2DecryptedByKey1 = new Uint8Array(
        await ephemeralKey1.decrypt(cipherText2),
      );

      expect(cipherText1DecryptedByKey2).toEqual(plainText);
      expect(cipherText2DecryptedByKey1).toEqual(plainText);
    });
  });

  it("cannot derive a shared ephemeral key with mismatching fingerprint", async () => {
    const teacherKeyPair = await generateTeacherKeyPair();
    const studentKeyPair = await generateStudentKeyPair();

    const myPublicKey = await teacherKeyPair.exportPublicKey();

    await expect(
      studentKeyPair.deriveSharedEphemeralKey(
        myPublicKey,
        "attacker fingerprint",
      ),
    ).rejects.toThrow();
  });
});
