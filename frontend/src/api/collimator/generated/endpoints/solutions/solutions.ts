/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Collimator
 * The Collimator API description (multi-version)
 * OpenAPI spec version: 1.0.0
 */
import { fetchApi } from "../../../../fetch";
import type {
  CreateSolutionDto,
  CurrentAnalysesDto,
  ExistingStudentSolutionDto,
  PatchStudentSolutionIsReferenceDto,
  SolutionsControllerDownloadLatestStudentSolutionV0Params,
  SolutionsControllerDownloadOneV0Params,
  SolutionsControllerFindCurrentAnalysesV0Params,
  SolutionsControllerFindOneStudentSolutionV0Params,
  SolutionsControllerPatchStudentSolutionIsReferenceV0Params,
} from "../../models";

export const getSolutionsControllerCreateStudentSolutionV0Url = (
  classId: number,
  sessionId: number,
  taskId: number,
) => {
  return `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student`;
};

export const solutionsControllerCreateStudentSolutionV0 = async (
  classId: number,
  sessionId: number,
  taskId: number,
  createSolutionDto: CreateSolutionDto,
  options?: RequestInit,
): Promise<ExistingStudentSolutionDto> => {
  const formData = new FormData();
  createSolutionDto.tests.forEach((value) =>
    formData.append(`tests`, JSON.stringify(value)),
  );
  formData.append(`file`, createSolutionDto.file);

  return fetchApi<ExistingStudentSolutionDto>(
    getSolutionsControllerCreateStudentSolutionV0Url(
      classId,
      sessionId,
      taskId,
    ),
    {
      ...options,
      method: "POST",
      body: formData,
    },
  );
};

export const getSolutionsControllerFindAllStudentSolutionsV0Url = (
  classId: number,
  sessionId: number,
  taskId: number,
) => {
  return `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student`;
};

export const solutionsControllerFindAllStudentSolutionsV0 = async (
  classId: number,
  sessionId: number,
  taskId: number,
  options?: RequestInit,
): Promise<ExistingStudentSolutionDto[]> => {
  return fetchApi<ExistingStudentSolutionDto[]>(
    getSolutionsControllerFindAllStudentSolutionsV0Url(
      classId,
      sessionId,
      taskId,
    ),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getSolutionsControllerFindCurrentAnalysesV0Url = (
  classId: number,
  sessionId: number,
  taskId: number,
  params?: SolutionsControllerFindCurrentAnalysesV0Params,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/current-analyses?${stringifiedParams}`
    : `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/current-analyses`;
};

export const solutionsControllerFindCurrentAnalysesV0 = async (
  classId: number,
  sessionId: number,
  taskId: number,
  params?: SolutionsControllerFindCurrentAnalysesV0Params,
  options?: RequestInit,
): Promise<CurrentAnalysesDto> => {
  return fetchApi<CurrentAnalysesDto>(
    getSolutionsControllerFindCurrentAnalysesV0Url(
      classId,
      sessionId,
      taskId,
      params,
    ),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getSolutionsControllerDownloadLatestStudentSolutionV0Url = (
  classId: number,
  sessionId: number,
  taskId: number,
  params?: SolutionsControllerDownloadLatestStudentSolutionV0Params,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student/latest?${stringifiedParams}`
    : `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student/latest`;
};

export const solutionsControllerDownloadLatestStudentSolutionV0 = async (
  classId: number,
  sessionId: number,
  taskId: number,
  params?: SolutionsControllerDownloadLatestStudentSolutionV0Params,
  options?: RequestInit,
): Promise<ExistingStudentSolutionDto> => {
  return fetchApi<ExistingStudentSolutionDto>(
    getSolutionsControllerDownloadLatestStudentSolutionV0Url(
      classId,
      sessionId,
      taskId,
      params,
    ),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getSolutionsControllerFindOneStudentSolutionV0Url = (
  classId: number,
  sessionId: number,
  taskId: number,
  id: number,
  params?: SolutionsControllerFindOneStudentSolutionV0Params,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student/${id}?${stringifiedParams}`
    : `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student/${id}`;
};

export const solutionsControllerFindOneStudentSolutionV0 = async (
  classId: number,
  sessionId: number,
  taskId: number,
  id: number,
  params?: SolutionsControllerFindOneStudentSolutionV0Params,
  options?: RequestInit,
): Promise<ExistingStudentSolutionDto> => {
  return fetchApi<ExistingStudentSolutionDto>(
    getSolutionsControllerFindOneStudentSolutionV0Url(
      classId,
      sessionId,
      taskId,
      id,
      params,
    ),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * @summary Delete all solutions by a student for a given session/task
 */
export const getSolutionsControllerDeleteOneStudentSolutionV0Url = (
  classId: number,
  sessionId: number,
  taskId: number,
  id: number,
) => {
  return `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student/${id}`;
};

export const solutionsControllerDeleteOneStudentSolutionV0 = async (
  classId: number,
  sessionId: number,
  taskId: number,
  id: number,
  options?: RequestInit,
): Promise<void> => {
  return fetchApi<void>(
    getSolutionsControllerDeleteOneStudentSolutionV0Url(
      classId,
      sessionId,
      taskId,
      id,
    ),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getSolutionsControllerDownloadOneV0Url = (
  classId: number,
  sessionId: number,
  taskId: number,
  hash: string,
  params?: SolutionsControllerDownloadOneV0Params,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/${hash}/download?${stringifiedParams}`
    : `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/${hash}/download`;
};

export const solutionsControllerDownloadOneV0 = async (
  classId: number,
  sessionId: number,
  taskId: number,
  hash: string,
  params?: SolutionsControllerDownloadOneV0Params,
  options?: RequestInit,
): Promise<void> => {
  return fetchApi<void>(
    getSolutionsControllerDownloadOneV0Url(
      classId,
      sessionId,
      taskId,
      hash,
      params,
    ),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * @summary Updates the isReference field of a student solution
 */
export const getSolutionsControllerPatchStudentSolutionIsReferenceV0Url = (
  classId: number,
  sessionId: number,
  taskId: number,
  id: number,
  params?: SolutionsControllerPatchStudentSolutionIsReferenceV0Params,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student/${id}/isReference?${stringifiedParams}`
    : `/api/v0/classes/${classId}/sessions/${sessionId}/task/${taskId}/solutions/student/${id}/isReference`;
};

export const solutionsControllerPatchStudentSolutionIsReferenceV0 = async (
  classId: number,
  sessionId: number,
  taskId: number,
  id: number,
  patchStudentSolutionIsReferenceDto: PatchStudentSolutionIsReferenceDto,
  params?: SolutionsControllerPatchStudentSolutionIsReferenceV0Params,
  options?: RequestInit,
): Promise<void> => {
  return fetchApi<void>(
    getSolutionsControllerPatchStudentSolutionIsReferenceV0Url(
      classId,
      sessionId,
      taskId,
      id,
      params,
    ),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(patchStudentSolutionIsReferenceDto),
    },
  );
};
